<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Seven&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="积跬步以至千里，积小流以成江海">
    
    <link rel="preload" href="/assets/css/0.styles.9a488dde.css" as="style"><link rel="preload" href="/assets/js/app.8fcb3c07.js" as="script"><link rel="preload" href="/assets/js/2.ea4b5fde.js" as="script"><link rel="preload" href="/assets/js/28.ac3b40d5.js" as="script"><link rel="preload" href="/assets/js/3.482fc7d1.js" as="script"><link rel="prefetch" href="/assets/js/10.ceaff0cb.js"><link rel="prefetch" href="/assets/js/11.602a1a57.js"><link rel="prefetch" href="/assets/js/12.7c9a3565.js"><link rel="prefetch" href="/assets/js/13.cb26c009.js"><link rel="prefetch" href="/assets/js/14.db9f58ed.js"><link rel="prefetch" href="/assets/js/15.c07f99aa.js"><link rel="prefetch" href="/assets/js/16.bbea5198.js"><link rel="prefetch" href="/assets/js/17.bd355204.js"><link rel="prefetch" href="/assets/js/18.069c6795.js"><link rel="prefetch" href="/assets/js/19.2d2f3f2c.js"><link rel="prefetch" href="/assets/js/20.4bf50484.js"><link rel="prefetch" href="/assets/js/21.1bfa4a30.js"><link rel="prefetch" href="/assets/js/22.9b54ca32.js"><link rel="prefetch" href="/assets/js/23.17047d1d.js"><link rel="prefetch" href="/assets/js/24.d36a307c.js"><link rel="prefetch" href="/assets/js/25.f5c553f3.js"><link rel="prefetch" href="/assets/js/26.cfb8865a.js"><link rel="prefetch" href="/assets/js/27.8d7291fd.js"><link rel="prefetch" href="/assets/js/29.d97a3e56.js"><link rel="prefetch" href="/assets/js/30.f58a4260.js"><link rel="prefetch" href="/assets/js/31.9294edd4.js"><link rel="prefetch" href="/assets/js/32.753d88bb.js"><link rel="prefetch" href="/assets/js/33.4259510b.js"><link rel="prefetch" href="/assets/js/34.767c2061.js"><link rel="prefetch" href="/assets/js/35.ee551374.js"><link rel="prefetch" href="/assets/js/36.67e65bf0.js"><link rel="prefetch" href="/assets/js/37.39a7a34a.js"><link rel="prefetch" href="/assets/js/4.6162bcf8.js"><link rel="prefetch" href="/assets/js/5.43fabd26.js"><link rel="prefetch" href="/assets/js/6.bfd296f5.js"><link rel="prefetch" href="/assets/js/7.da21fdf7.js"><link rel="prefetch" href="/assets/js/8.13301773.js"><link rel="prefetch" href="/assets/js/9.d46e2aae.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9a488dde.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Seven's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web/" class="nav-link router-link-active">
  web前端
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web/" class="nav-link router-link-active">
  web前端
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web/React/React基础.html" class="sidebar-link">React基础</a></li><li><a href="/web/React/如何开发React应用.html" class="active sidebar-link">如何开发React应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_1-第一步-设计阶段-为ui划分组件层级" class="sidebar-link">1. 第一步：设计阶段，为UI划分组件层级</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_1-组件的划分原则-单一功能原则" class="sidebar-link">1. 组件的划分原则：单一功能原则</a></li><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_2-以数据模型为基础设计组件" class="sidebar-link">2. 以数据模型为基础设计组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_2-开发阶段-编写组件" class="sidebar-link">2. 开发阶段：编写组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_1-第二步-先创建一个静态的版本-创建出不具有任何交互的组件" class="sidebar-link">1. 第二步：先创建一个静态的版本，创建出不具有任何交互的组件</a></li><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_2-第三步-确定ui-state-的最小且完整表示" class="sidebar-link">2. 第三步：确定UI state 的最小且完整表示</a></li><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_3-第四步-确定-state-放置的位置" class="sidebar-link">3. 第四步：确定 state 放置的位置</a></li><li class="sidebar-sub-header"><a href="/web/React/如何开发React应用.html#_4-第五步-添加反向数据流" class="sidebar-link">4. 第五步：添加反向数据流</a></li></ul></li></ul></li><li><a href="/web/React/Redux基础.html" class="sidebar-link">Redux基础</a></li><li><a href="/web/React/Redux进阶.html" class="sidebar-link">Redux进阶</a></li><li><a href="/web/React/从零开始实现一个Redux.html" class="sidebar-link">从零开始实现一个Redux</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react-router</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>UmiJS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Utils</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/web/Mobile.html" class="sidebar-link">Mobile</a></li><li><a href="/web/ElementUI.html" class="sidebar-link">ElementUI</a></li><li><a href="/web/FastMock.html" class="sidebar-link">fastmock</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试题</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><a href="https://codesandbox.io/s/nice-haze-khxfk?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener noreferrer">开发一个React应用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_1-第一步-设计阶段-为ui划分组件层级"><a href="#_1-第一步-设计阶段-为ui划分组件层级" class="header-anchor">#</a> 1. 第一步：设计阶段，为UI划分组件层级</h2> <h3 id="_1-组件的划分原则-单一功能原则"><a href="#_1-组件的划分原则-单一功能原则" class="header-anchor">#</a> 1. 组件的划分原则：单一功能原则</h3> <p>组件原则上只负责一个功能。如果它需要负责更多的功能，就需要考虑将它拆分为更小的组件。例如，一个 TodoList 应用，应当如下划分组件：
<div class="img-wrapper"><img src="https://i.loli.net/2020/03/01/dmS42uB7qDnrEgY.png" alt="组件层级划分" class="zoom-img"> <p>组件层级划分</p></div></p> <ul><li><code>TodoList</code> <ul><li><code>AddBar</code></li> <li><code>List</code> <ul><li><code>ListItem</code></li></ul></li></ul></li></ul> <h3 id="_2-以数据模型为基础设计组件"><a href="#_2-以数据模型为基础设计组件" class="header-anchor">#</a> 2. 以数据模型为基础设计组件</h3> <p>大部分的应用通常都是向用户展示 JSON 数据模型的，这些数据模型通常是从数据库获取，然后经后台转化成 JSON ，返回至前端。所以如果模型设计的合理，UI层（也就是组件结构）应当与数据模型一一对应，这是因为UI和数据模型都会倾向于遵守相同的信息结构。</p> <h2 id="_2-开发阶段-编写组件"><a href="#_2-开发阶段-编写组件" class="header-anchor">#</a> 2. 开发阶段：编写组件</h2> <p>开发时最好将<strong>渲染UI</strong>和<strong>添加交互</strong>这两个过程分开。这是因为，编写一个应用的静态时，往往需要编写大量的代码，而不需要考虑过多的交互细节，能够较好较快的呈现出设计内容；而添加交互阶段则需要考虑大量的细节，如数据流动，逻辑控制等，而不需要编写大量的代码。所以，将这两个过程分开进行更为合适。</p> <h3 id="_1-第二步-先创建一个静态的版本-创建出不具有任何交互的组件"><a href="#_1-第二步-先创建一个静态的版本-创建出不具有任何交互的组件" class="header-anchor">#</a> 1. 第二步：先创建一个静态的版本，创建出不具有任何交互的组件</h3> <p>按照上述的组件划分，用已有的数据模型先编写出<strong>不具有任何交互的纯静态组件</strong>。</p> <div class="custom-block warning"><p class="custom-block-title">构建静态版本时应注意</p> <p>在构建应用的静态版本时，<strong>不应该使用 state 构建静态版本</strong>，因为 state 代表的是可能产生变化的数据，应当仅在实现交互时使用。 应当使用 props 来进行数据自上而下的传递。</p></div> <ol><li>编写组件顺序<br>
构建组件的顺序可以是<strong>自下而上</strong>或是<strong>自上而下</strong>的，就是可以从最外层或最里层开始编写，例如案例中的<code>TodoList</code>为最外层组件，<code>ListItem</code>则为最里层组件。这取决应用的复杂程度和开发经验，自下而上的构建应用，往往适用于复杂的项目，这通常也更利于单组件的测试。</li> <li>纯静态的版本只有 <code>render()</code> 函数<br>
因为没有任何交互功能，所以不会存在 <code>this</code> ，只有 props ，在构建的纯静态版本组件中只需提供 <code>render()</code> 方法来用于渲染即可。</li> <li><code>props</code> 和 <code>state</code> 的区别<br> <code>props</code>（&quot;properties&quot;的缩写）和 <code>state</code>都是普通的 JavaScript 对象。它们在React中的作用都是用来保存信息的，这些信息可以控制组件的渲染输出，它们最主要的不同点就是：
<ul><li><code>props</code> 是传递给组件的（类似于函数的传参）</li> <li><code>state</code> 是在组件内被组件自己管理的（类似于函数内声明的变量），外部是无法访问和控制的</li> <li><code>props</code> 是只读的，无法被修改</li> <li><code>state</code> 是可变的，可以被修改</li></ul></li></ol> <h3 id="_2-第三步-确定ui-state-的最小且完整表示"><a href="#_2-第三步-确定ui-state-的最小且完整表示" class="header-anchor">#</a> 2. 第三步：确定UI state 的最小且完整表示</h3> <p>想要使 UI 具备交互功能，需要有触发基础数据模型改变的能力，也就是说要发生数据的变化。在React基础中说到， <strong><code>props</code> 永远都是只读的，它不可能被修改</strong>，而 <code>state</code> 是组件内部的状态，是可变化的，所以React 通过实现 <code>state</code> 来完成数据变化的任务。<br>
为了正确的构建应用的交互，首先需要找出应用所需的 <code>state</code> 的最小表示，并根据需要计算出其他所有的数据。那么何为 <code>state</code> 的最小表示呢，例如，编写一个任务清单应用，你只需要拥有一个保存所有事项的数组 <code>state</code> 即可，而无需额外新建一个单独的 <code>state</code> 来保存任务个数，当需要展示任务个数时，只需要利用该数组的 <code>length</code> 属性即可。<br>
案例中的 TodoList 应用拥有如下数据：</p> <ul><li>用户输入的新增内容</li> <li>默认 toto 列表内容</li> <li>新增 toto 列表内容</li></ul> <p><strong>通过三个问题，可以逐个检查相应的数据是否属于 state ：</strong></p> <ol><li><strong>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state;</strong></li> <li><strong>该数据是否随着时间推移而保持不变？如果是，那它应该不是 state;</strong></li> <li><strong>该数据是否可以由其他 state 或 props 计算得出？如果是，那它应该不是 state。</strong></li></ol> <p>用户输入的新增内容，会发生变化且无法由其他数据计算或得出，所以应该是 state；默认 todo 列表内容由 props 传入，所以它不是 state ；新增 todo 列表内容会发生变化所以应该也是 state。<br>
综上所述，属于 state 的有：</p> <ul><li>用户输入的新增内容</li> <li>新增 todo 列表内容</li></ul> <h3 id="_3-第四步-确定-state-放置的位置"><a href="#_3-第四步-确定-state-放置的位置" class="header-anchor">#</a> 3. 第四步：确定 state 放置的位置</h3> <p>确定了所需的 state 最小集合后，接下来，需要确定哪个组件能够改变这些 state ，或者说共享这些 state。<br>
React中是<strong>单向数据流</strong>，并且是顺着组件层级从上往下瀑布式传递的。哪个组件应该拥有某个 state ，有时候会很难区分。但是可以通过以下步骤来进行判断：</p> <p><strong>对于应用中的每一个 state ：</strong></p> <ul><li><strong>找到根据这个 state 进行渲染的所有组件。</strong></li> <li><strong>找他们共同的父组件（共同所有者common owner组件），它是一个在组件层级上高于所有拥有该 state 的组件。</strong></li> <li><strong>该共同所有者组件或比它层级更高的组件应该拥有此 state。</strong></li> <li><strong>如果找不到合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件（他们的父组件）层级的位置。</strong></li></ul> <p>根据以上策略重新考虑示例应用：</p> <ul><li><code>list</code> 需要根据新增 state 渲染列表，<code>listItem</code> 需要删除列表项。<code>AddBar</code> 需要展示新增词, <code>addBar</code> 新增内容要添加进新增 todo 列表内容。</li> <li>它们的共同所有者是 <code>TodoList</code></li> <li>因此，新增内容 state 和新增 todo 列表内容的 state 都应该放在 <code>TodoList</code> 中。</li></ul> <h3 id="_4-第五步-添加反向数据流"><a href="#_4-第五步-添加反向数据流" class="header-anchor">#</a> 4. 第五步：添加反向数据流</h3> <p>到目前为止，借助自上而下传递的 props 和 state 渲染了一个应用。但是当点击输入新增内容的时候是没有反应的，这是因为较低层级的表单中input 的值设置为了从 <code>TodoList</code> 的 <code>state</code> 传递而来的固定值。
重新梳理下想要实现的功能：</p> <ol><li>输入功能：每当用户改变表单的值，都需要改变 state 来反映用户的当前输入操作。由于 state 在外部无法访问，只能由拥有它们的组件进行更改，所以 <code>TodoList</code> 组件中必须有一个能够触发 state 改变的回调函数传递给 <code>addBar</code>。然后使用输入框的 <code>onChange</code> 事件来监听用户输入的变化，触发回调函数，从而触发输入框的更新。</li> <li>新增功能：当点击新增按钮的时候，也会触发 <code>TodoList</code> 中的新增回调函数，使用 <code>setState()</code> 改变 list state 的内容，将输入的内容添加至 TODO 列表，从而更新整个列表。</li> <li>删除功能：当用户点击删除按钮的时候，触发了 <code>TodoList</code> 删除回调函数，使用 <code>setState()</code> 改变 list state 的内容，来更新列表。</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">12/1/2020, 4:35:44 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/web/React/React基础.html" class="prev">
        React基础
      </a></span> <span class="next"><a href="/web/React/Redux基础.html">
        Redux基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8fcb3c07.js" defer></script><script src="/assets/js/2.ea4b5fde.js" defer></script><script src="/assets/js/28.ac3b40d5.js" defer></script><script src="/assets/js/3.482fc7d1.js" defer></script>
  </body>
</html>
