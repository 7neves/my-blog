[开发一个React应用](https://codesandbox.io/s/nice-haze-khxfk?fontsize=14&hidenavigation=1&theme=dark)
## 1. 第一步：设计阶段，为UI划分组件层级
### 1. 组件的划分原则：单一功能原则
组件原则上只负责一个功能。如果它需要负责更多的功能，就需要考虑将它拆分为更小的组件。例如，一个 TodoList 应用，应当如下划分组件：
<img-show :img-info="{src:'https://i.loli.net/2020/03/01/dmS42uB7qDnrEgY.png',description:'组件层级划分'}"/>
- `TodoList`
  - `AddBar`
  - `List`
    - `ListItem`

### 2. 以数据模型为基础设计组件
大部分的应用通常都是向用户展示 JSON 数据模型的，这些数据模型通常是从数据库获取，然后经后台转化成 JSON ，返回至前端。所以如果模型设计的合理，UI层（也就是组件结构）应当与数据模型一一对应，这是因为UI和数据模型都会倾向于遵守相同的信息结构。
## 2. 开发阶段：编写组件
开发时最好将**渲染UI**和**添加交互**这两个过程分开。这是因为，编写一个应用的静态时，往往需要编写大量的代码，而不需要考虑过多的交互细节，能够较好较快的呈现出设计内容；而添加交互阶段则需要考虑大量的细节，如数据流动，逻辑控制等，而不需要编写大量的代码。所以，将这两个过程分开进行更为合适。
### 1. 第二步：先创建一个静态的版本，创建出不具有任何交互的组件
按照上述的组件划分，用已有的数据模型先编写出**不具有任何交互的纯静态组件**。 
::: warning 构建静态版本时应注意 
在构建应用的静态版本时，**不应该使用 state 构建静态版本**，因为 state 代表的是可能产生变化的数据，应当仅在实现交互时使用。 应当使用 props 来进行数据自上而下的传递。
:::
1. 编写组件顺序  
构建组件的顺序可以是**自下而上**或是**自上而下**的，就是可以从最外层或最里层开始编写，例如案例中的`TodoList`为最外层组件，`ListItem`则为最里层组件。这取决应用的复杂程度和开发经验，自下而上的构建应用，往往适用于复杂的项目，这通常也更利于单组件的测试。  
2. 纯静态的版本只有 `render()` 函数  
因为没有任何交互功能，所以不会存在 `this` ，只有 props ，在构建的纯静态版本组件中只需提供 `render()` 方法来用于渲染即可。
3.  `props` 和 `state` 的区别  
`props`（"properties"的缩写）和 `state`都是普通的 JavaScript 对象。它们在React中的作用都是用来保存信息的，这些信息可以控制组件的渲染输出，它们最主要的不同点就是：
    - `props` 是传递给组件的（类似于函数的传参）
    - `state` 是在组件内被组件自己管理的（类似于函数内声明的变量），外部是无法访问和控制的
    - `props` 是只读的，无法被修改
    - `state` 是可变的，可以被修改
### 2. 第三步：确定UI state 的最小且完整表示
想要使 UI 具备交互功能，需要有触发基础数据模型改变的能力，也就是说要发生数据的变化。在React基础中说到， **`props` 永远都是只读的，它不可能被修改**，而 `state` 是组件内部的状态，是可变化的，所以React 通过实现 `state` 来完成数据变化的任务。  
为了正确的构建应用的交互，首先需要找出应用所需的 `state` 的最小表示，并根据需要计算出其他所有的数据。那么何为 `state` 的最小表示呢，例如，编写一个任务清单应用，你只需要拥有一个保存所有事项的数组 `state` 即可，而无需额外新建一个单独的 `state` 来保存任务个数，当需要展示任务个数时，只需要利用该数组的 `length` 属性即可。  
案例中的 TodoList 应用拥有如下数据：
- 用户输入的新增内容
- 默认 toto 列表内容
- 新增 toto 列表内容  

**通过三个问题，可以逐个检查相应的数据是否属于 state ：**
1. **该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state;**
2. **该数据是否随着时间推移而保持不变？如果是，那它应该不是 state;**
3. **该数据是否可以由其他 state 或 props 计算得出？如果是，那它应该不是 state。**  

用户输入的新增内容，会发生变化且无法由其他数据计算或得出，所以应该是 state；默认 todo 列表内容由 props 传入，所以它不是 state ；新增 todo 列表内容会发生变化所以应该也是 state。  
综上所述，属于 state 的有：
- 用户输入的新增内容
- 新增 todo 列表内容
### 3. 第四步：确定 state 放置的位置
确定了所需的 state 最小集合后，接下来，需要确定哪个组件能够改变这些 state ，或者说共享这些 state。  
React中是**单向数据流**，并且是顺着组件层级从上往下瀑布式传递的。哪个组件应该拥有某个 state ，有时候会很难区分。但是可以通过以下步骤来进行判断： 

**对于应用中的每一个 state ：**
- **找到根据这个 state 进行渲染的所有组件。**
- **找他们共同的父组件（共同所有者common owner组件），它是一个在组件层级上高于所有拥有该 state 的组件。**
- **该共同所有者组件或比它层级更高的组件应该拥有此 state。**
- **如果找不到合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件（他们的父组件）层级的位置。**  

根据以上策略重新考虑示例应用：
- `list` 需要根据新增 state 渲染列表，`listItem` 需要删除列表项。`AddBar` 需要展示新增词, `addBar` 新增内容要添加进新增 todo 列表内容。
- 它们的共同所有者是 `TodoList`
- 因此，新增内容 state 和新增 todo 列表内容的 state 都应该放在 `TodoList` 中。

### 4. 第五步：添加反向数据流
到目前为止，借助自上而下传递的 props 和 state 渲染了一个应用。但是当点击输入新增内容的时候是没有反应的，这是因为较低层级的表单中input 的值设置为了从 `TodoList` 的 `state` 传递而来的固定值。
重新梳理下想要实现的功能：
1. 输入功能：每当用户改变表单的值，都需要改变 state 来反映用户的当前输入操作。由于 state 在外部无法访问，只能由拥有它们的组件进行更改，所以 `TodoList` 组件中必须有一个能够触发 state 改变的回调函数传递给 `addBar`。然后使用输入框的 `onChange` 事件来监听用户输入的变化，触发回调函数，从而触发输入框的更新。
2. 新增功能：当点击新增按钮的时候，也会触发 `TodoList` 中的新增回调函数，使用 `setState()` 改变 list state 的内容，将输入的内容添加至 TODO 列表，从而更新整个列表。
3. 删除功能：当用户点击删除按钮的时候，触发了 `TodoList` 删除回调函数，使用 `setState()` 改变 list state 的内容，来更新列表。