防抖和节流都是通过限制<基于DOM事件来执行js函数>次数，来达到节省资源，从而优化性能的方法。不同点是限制的方式。  
例如window.onresize事件，scroll事件，submit事件，mouseover事件...如果事件中绑定了函数，每次的事件触发就都会导致浏览器消耗性能，最终导致用户体验下降（UI卡顿，浏览器卡死等等）。  
- 参考：
  - [https://zhuanlan.zhihu.com/p/38313717](https://zhuanlan.zhihu.com/p/38313717)  
  - [https://juejin.im/entry/58c0379e44d9040068dc952f](https://juejin.im/entry/58c0379e44d9040068dc952f)
## 1. 函数防抖(debounce)
>触发高频事件delay秒后再执行回调，如果在这delay秒内被再次触发，则重新计时。  

实际意义是限制了函数多久才能执行一次
- 思路：
  1. 使用定时器延时触发事件执行的函数，让函数在delay时间后再执行，以达到事件延时执行的目的
  2. 在delay时间内，高频触发事件的时候，清除定时器，此时会重新进行计时，就可以防止事件内的函数高频触发
  3. 到达delay时间，最终触发事件内的函数
- 适用场景：
  - window.onresize事件，表单的服务器验证，远程实时查询，输入提交等等；其次是防止频繁的提交，造成请求的阻塞
```js
/**
  * 可以理解为多人上电梯，假设电梯无限大，但是会有等待时间限制，每有一个人按电梯，都会重新计时，当最后一个人进入电梯后，电梯才会开始运转
  * @param {Function} callback 防抖需要执行的方法
  * @param {Number} delay 防抖时间
  */
debounce(callback, delay) {
  // 构建闭包函数，将定时器保存在内存中，可以在频繁执行时，清除定时器，已进行“防抖”
  let timer;
  function closer() {
    /**
      * 清除上次构造的定时器
      * 这样如果在delay定时内，再次执行callback就不会触发定时器内的方法，因为每次执行callback总会先清除上次构造的定时器，定时器内的方法就不会执行，达到防抖
      */
    // console.log(`上次构造的定时器编号：${timer}`);
    clearTimeout(timer);
    /**
      * 防抖的目的是，在delay时间内，频繁的触发，只执行一次
      * 构造新的定时器，在最后一次执行callback的时候总会触发该定时器，
      */
    timer = setTimeout(()=>{
      callback.apply(this,arguments);
    }, delay);
    // 可以看到，如果在delay时间内，频繁的再次执行callback，两次的定时器编号是一样的
    // console.log(`构造的新的定时器编号：${timer}`);
  }
  return closer;
}
```
<iframe width="100%" height="300" src="//jsrun.net/DtaKp/embedded/result,js/light" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
## 2. 函数节流(throttle)
>触发高频事件，但在interval秒内必定会执行一次，目的是稀释函数执行频率。  

实际意义是限制了函数多久内必须执行一次
- 思路：
  可以有两种实现思路：
  1. 通过时间差方式
    - 通过闭包的方式，在内部函数执行前，设定初始时间，内部函数开始执行时，设定新的时间，新的时间-初始时间>=interval时间，就会执行事件触发的函数，然后更新初始时间，高频触发也只能在interval时间段内执行函数。
  2. 通过设定标记的方式
    - 通过闭包的方式，创建标记，每次触发事件都通过判断标记，来确定当前是否有等待执行的延时函数
```js
/**
  * 可以理解为：大坝的截流，需要在某个时间段内执行一次放水的操作，以防止决堤
  * 时间差方式:
  * @param {Function} callback 节流需要执行的方法
  * @param {Number} interval 节流触发函数的间隔时间
  */
throttle(callback, interval) {
  let timer;
  let start = Date.now();
  function closer() {
    clearTimeout(timer);
    let current = Date.now();
    if (current - start >= interval) {
      // 时间段内执行一次方法
      // console.log(`${current - start}`);
      // console.log(`${interval}差不多到了，执行一次`);
      callback.apply(this, arguments);
      // 时间初始化
      start = current;
    }
  }
  return closer;
}

// 标记方式
function flagThrottle(callback, interval) {
  let flag = false; // 通过闭包设置标记
  function closer() {
    if (flag) { 
      return;
    }
    flag = true;
    setTimeout(() => {
      callback.apply(this, arguments);
      flag = false;
    }, interval);
  }
  return closer;
}
```
<iframe width="100%" height="300" src="//jsrun.net/6taKp/embedded/result,js/light" allowfullscreen="allowfullscreen" frameborder="0"></iframe>