参考：  
《你不知道的JavaScript（上卷）》  
《JavaScript高级程序指南3》  
结合参考资料及Google，对JavaScript底层概念做个简单的总结，便于自己的理解，也方便以后查缺补漏，仅供参考。
## 1. 编译原理
在传统编译语言的流程中，从大的方面来讲，程序中的一段源代码在执行前会经历三个步骤：
  - **分词/词法分析**  
    词法化阶段，这个过程会将由字符组成的字符串分解成有意义的代码块（对编程语言来说）
  - **解析/语法分析**  
    这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套多组成的代表了程序语法结构的树，就是**抽象语法树（AST）**。以 `var a = 2;` 语句举例：
    <img-show :img-info="{src:'https://i.loli.net/2019/11/05/qWuAw6iI9Qn3TUd.png',description:'抽象语法树'}" />
  - **代码生成**  
    这个阶段是将AST转换为可执行代码的过程。  

JavaScript也是一门需要编译的语言，但是比起传统编译语言的三个步骤，JavaScript会更为复杂（一些编译优化等）；对于JavaScript来说，大部分情况下**编译发生在代码执行前**的极短的时间内；任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）；因此JavaScript编译器首先会对`var a = 2;`这段程序进行编译，将其转化为一组机器指令，用来创建一个叫做a的变量（包括为其分配内存等），并将一个值储存在a中，这样就完成了一个代码编译执行的过程。
## 2. 作用域
### 2.1 **概念**  
在《你不知道的JavaScript（上卷）--作用域是什么》 章节，用“演员对话”的方式很生动的介绍了引擎、编译器和作用域的关系，它们是一个层级的概念，“并且关系要好”，是互相协同合作的关系。  
  - 引擎  
    负责整个JavaScript程序的编译及执行过程。
  - 编译器  
    负责语法分析及代码生成等编译工作
  - 作用域  
    > **作用域是一套规则，用于规定在何处以及如何查找变量**。它负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

  还是`var a = 2;`这条语句的执行，文中提出了一个合理的假设：“为一个变量分配内存，并将其命名为a，然后将值2保存进这个变量。”起初我确实是这么认为的，然鹅，这并不完全正确，来看看JavaScript整个执行过程中它们三者是如何工作的：
  <img-show :img-info="{src:'https://i.loli.net/2019/11/06/6tPEu8pgjlcYoRB.png',description:'变量的赋值操作'}"/>

  - 总结：**作用域是一套规则，用于确定当前执行代码可访问变量的权限**。

### 2.2 **作用域嵌套及查找规则**  
先看一个简单的例子：
  ```js
  var a = 1,
      c = 4;
  function foo() {
    var a = 2,
        b = 3;
    function bar() {
      console.log(a, b, c);
    }
    bar();
  }
  foo(); // 2, 3, 4
  ```
  > 当一个块或函数嵌套在另一个块或函数中时，就会发生作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域（也就是全局作用域）为止。

  所以，上述的代码可以分为如下三个作用域的嵌套：
    <img-show :img-info="{src:'https://i.loli.net/2019/11/05/QViTD7nNIqewMWX.png',description:'作用域示例'}"/>
    在bar函数中是不存在a, b, c三个变量的，所以会向上进行查找，在其父级作用域foo函数中找到了a和b两个变量，所以会立即停止查找，不再进行查找；没有找到c会继续向上查找，在全局作用域中找到了c；然后输出它们的值。  
  - 总结： **作用域查找始终从运行时所处的最内部作用域开始，逐级向上进行查找，直到遇见第一个匹配的标识符为止，会停止不再查找**  
### 2.3 **作用域链**
  - 概念：当要查找的某个变量，在当前作用域中不存在时，就会逐级向上进行查找，直到全局作用域，这种作用域层层嵌套的结构，就构成了作用域链。  
  - 用途：**作用域链的用途，就是为了保证对执行环境有权访问的所有变量和函数进行有序的访问。**  
## 3. 词法作用域
### 3.1 概念
在《编译原理》章节说到在编译的第一个阶段，会进行词法化，这个过程会对源代码中的字符进行检查，分析成对编程语言有意义的代码。  
而词法作用域就是定义在该阶段的作用域，而且一旦定义就不会被改变（大部分情况下是这样的，特殊情况如欺骗词法作用域等除外）。也就是说**在写代码时函数声明的书写位置决定了函数的作用域范围**，一个很典型的例子：
```js
var a = 1;
function foo() {
  console.log(a);
}
function bar() {
  var a = 2;
  foo();
}
bar(); // 1
```
按书写代码的内容，在foo()函数定义的时候，已经持有对全局变量a的引用，所以不论在何处执行，都是持有对全局变量a的引用。  
总结：**无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定**。
- **欺骗词法**  
上文说到，词法作用域是在写代码期间定义的，那么在**运行时**有没有方法可以定义词法作用域呢？在JavaScript中提供了两种方法，因为它们能使代码看起来非常难以理解，更重要的是导致代码运行变的很慢，所以**不推荐使用**，这里只做了解:
  - eval()函数
  - width
### 3.2 闭包
建议：**理解其它所有章节之后再来看这一章节**  
我们知道函数也是对象的一种，函数名只是指向当前函数的一个指针，将函数名以值的方式进行传递的时候，就会将函数进行传递，利用这一特征可以将内部函数传递到其所在词法作用域以外的位置；词法作用域又规定了函数在定义时可以访问的作用域范围；这两个特征构成了**闭包：突破作用域的限制，在函数外部也持有对函数作用域的引用，访问函数作用域内部的变量**。本质上是词法作用域的体现。举个栗子：
```js
function foo() {
  var a = "I'm foo function scope's variable";
  function bar() {
    console.log(a);
  }
  return bar; // 将函数名返回，也就是返回了bar函数的执行逻辑
}
var otherBar = foo(); // 此时的 otherBar 指向的是 bar 函数，持有对内部函数bar函数的引用
otherBar(); // "I'm foo function scope's variable" ----兄得，这就是闭包的效果。
```
**只要能将函数进行传递，实现方式是无所谓的**，理解了这一点，相信你能实现各种花里胡哨的闭包：
```js
// 例1
foo(); // 1
function foo() {
  var a = 1;
  function bar() {
    console.log(a);
  }
  otherBar(bar);
}

// 回调函数式
function otherBar(fn) {
  fn(); // 这就是闭包哟
}

// 例2
var baz;
function foo() {
  var a = 1;
  function bar() {
    console.log(a);
  }
  // 向外部变量传递函数
  baz = bar; 
}
foo();
baz(); // 1 闭包
```
## 4.函数作用域
### 4.1 概念
**函数作用域就是指变量只在当前函数体及嵌套的函数体内可访问，外部作用域是无法访问函数作用域内部的任何内容的**。如：
```js
function foo() {
  var a = 1;
  function bar() {
    console.log(a, b);
  }
  var b = 2;
  bar();
}
foo(); // 1, 2
bar(); // Uncaught ReferenceError: bar is not defined
console.log(b); // Uncaught ReferenceError: b is not defined
```
### 4.2 防止变量污染  
先来看一个不怎么常见，确常用的概念，“最小暴露原则”：
> 在软件程序设计中，应该最小限度的暴露必要的内容，而将其它内容都“隐藏”起来，比如某个模块或对象的API设计。

我们知道，平常写代码的时候都会注意一个问题，就是如何防止全局变量的冲突（污染），如果将变量和函数都声明在全局作用域（或某个函数作用域）中，就会导致同名标识符的冲突，这种高耦合性的代码组织方式破坏了最小暴露原则，并不利于项目的构建，所以利用函数作用域的特性，可以“将变量和函数声明隐藏”，以防止变量的污染。如：
```js
var b;
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b);
}
function doSomethingElse(a) {
  return a - 1;
}
doSomething(2); // 5
```
私有变量`b`和函数`doSomethingElse()`声明在了全局作用域下，这就破坏了最小暴露原则，导致变量的污染，都可以对这些私有变量和函数进行访问，所以正确的做法是，将这些变量和函数私有化，使其在`doSomething()`函数外无法访问：
```js
function doSomething(a) {
  var b;
  function doSomethingElse(c) {
    return c - 1;
  }
  b = a + doSomethingElse(a * 2);
  console.log(b);
}
doSomething(2); // 5
```
这种变量污染的情况，在项目中使用了多个第三方库的情况下尤为明显，所以通常封装某个插件/API时，要尽可能的利用“最小暴露原则”，将变量和函数私有化。例如：
```js
var MyPluginFunName = {
  options: {
    // ...
  },
  doSomething: function () {
    // ...
  },
  doAnotherThing: function() {
    // ...
  }
 }
```
通过在全局作用域中声明一个名字足够独特的变量（通常是对象），这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，**而不是将自己所有的标识符暴露在顶级的词法作用域中**
### 4.3 立即执行函数
当使用声明函数的方式来“隐藏变量和函数声明”创建私有变量的时候，会有一个问题：声明的具名函数，也会污染当前所在作用域，如下：
```js
var a = 1;
function foo() {
  var a = 2;
  console.log(a); // 2
}
foo();
console.log(a); // 1
```
此时的foo函数仍然是污染了当前作用域（例子中为全局作用域），其次是必须显式的调用这个函数才能运行其中的代码。如何做到函数名不污染作用域，并且能自执行，这样就更好了。我想大多数人都想到了一个常用的方法：**[立即执行函数表达式](https://developer.mozilla.org/zh-CN/docs/Glossary/立即执行函数表达式)（IIFE：Immediately Invoked Function Expression）**。上例可以修改为:
```js
var a = 1;
(function foo(){
  var a = 2;
  console.log(a); // 2
})();
console.log(a); // 1
console.log(foo); // Uncaught ReferenceError: foo is not defined
```
**在`function`关键字前面加上`(`(必须成对出现)以及一元运算符`-`、`+`、`!`、`~`，会被当作函数表达式来处理（当函数有返回结果时，一元运算符还会将函数的返回结果进行运算，所以需要注意）**，之后使用`()`可以创建一个立即执行表达式，直接执行函数。使用圆括号运算符`()`将函数包裹起来，不仅避免了外界访问此函数作用域中的变量，而且不会污染外部作用域。 
- 关于匿名和具名  
  上述例子中的立即执行函数是一个具名函数，常见的其实大部分都是匿名的，但是具名的函数表达式比匿名函数表达式具有更多的优点，**应该始终给函数表达式命名**，以使代码更加容易阅读，更易维护：
  - 匿名的函数在栈追踪中不会显示出有意义的函数名，这样会使调试变得很困难。
  - 如果没有函数名，当函数需要引用自身时，只能使用已经过时的[`argument.callee`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee)属性，例如在递归中。
  - 匿名函数省略了对于代码可读性/可理解性很重要的函数名。
- 关于函数表达式和函数声明  
  在《你不知道的JavaScript（上卷）》一书中提到如何简单的区分函数声明和函数表达式：
  > 看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
  - 函数表达式可以是匿名的，也可以是具名的，但是函数声明则不可以省略函数名
- IIFE的改进形式：`(function(){}())`;这种形式与常用的`(function(){})()`别无二致，功能上都是一样的。
  - **🌟推荐**：IIFE还有一种看上去略显冗长，但是更易理解的书写方式：将需要运行的函数放在第二个圆括号中()，在IIFE执行之后当作参数传递进去。例如：
    ```js
    var a = 1;
    (function IIFE(foo){
      foo();
    })(function foo(){
      var a = 2;
      console.log(a); // 2
    });
    console.log(a); // 1
    ```
    其中第二个圆括号中的foo函数为一个参数，这样的代码看起来更易理解。
## 5. 关于提升
先来看几个典型的例子：
```js
// 例1
console.log(b); // undefined
var b = 1;

// 例2
foo(); // This is foo function
function foo() {
  console.log('This is foo function');
}

// 例3
bar(); // TypeError: bar is not a function
var bar = function () {
  console.log('This is bar function');
}
```
### 5.1 声明提升
在《作用域》章节说到在编译阶段会找到所有的声明，并生成作用域规则将它们关联起来。结合上述例子证明，**包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理**。按照这样的处理方式，上述例子可以做如下修改来进行理解：
```js
// 例1
var b; // 变量声明提升
console.log(b); // undefined
b = 1;

// 例2
function foo() { // 函数声明提升
  console.log('This is foo function');
}
foo(); // This is foo function

// 例3
var bar; // 函数表达式并不会被提升，而只是作为一个变量来进行提升
bar(); // 因为此时的bar为undefined类型，但是被当作一个函数来执行，所以报错TypeError: bar is not a function
bar = function () {
  console.log('This is bar function');
}
```
因此可以这样定义**声明提升：在代码本身被执行前，无论声明出现在什么地方，变量和函数的声明都会被提升至代码的顶部。**
  - 这个过程发生在编译阶段的
  - 提升操作会发生在所有作用域内部（并非整个程序中）。如：
    ```js
    foo(); // undefined
    console.log(a); // ReferenceError: a is not defined
    function foo() {
      // 声明的提升只是发生在foo函数作用域内部
      console.log(a);
      var a = 1;
    }
    ```
### 5.2 函数优先
我们知道函数和变量的声明都会被提升。如果声明同名变量和函数会发生什么事情呢？
```js
foo(); // This is foo function declaration
var foo;
function foo() {
  console.log('This is foo function declaration');
}
foo = function () {
  console.log('This is function expression');
};
```
尽管 `var foo` 出现在函数声明之前，但它是**重复的声明**（因此被忽略了），**因为函数声明会被提升到变量声明之前**。
  - 避免在在同一个作用域中进行重复的定义。
## 5. 执行环境
- **概念**  
  执行环境（又称为执行上下文环境或环境），是ECMAScript **运行时(runtime)** 的上下文环境：
  > 执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。  

  > 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。栈将其环境弹出，把控制权返回给之前的（上一层）执行环境。
  
  --《JavaScript高程3》  
  也就是说**每个函数都有自己的执行环境**，这就是**局部执行环境**，最外层的执行环境为**全局执行环境**（全局执行环境会根据ECMAScript实现的宿主环境的不同而改变，在web浏览器中，全局执行环境就是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的）。
- **特征**  
由于栈是先进后出的的结构，综合上文，执行环境有以下特点：
  - 同步执行（只有栈顶的执行环境处于执行中，其它的执行环境都在等待）
  - 单线程（依次执行）
  - 唯一的全局执行环境
  - 局部执行环境没有数量的限制
  - 函数的每次调用，都会创建一个新的局部环境，即便是多次调用同一个函数，也会创建多个不同的局部环境  
- **生命周期**  
执行环境可以分为创建和执行两个阶段；
  - 在创建阶段，解析器会创建执行环境的**变量对象**，建立作用域链，确定`this`的指向；
  - 在执行阶段，代码被解释执行。  
  <img-show :img-info="{src:'https://i.loli.net/2019/11/05/mciYX2DITr9KEtb.png',description:'执行环境生命周期'}"/>

## 1.3 作用域链
在执行环境的生命周期中，创建阶段会建立作用域链。
 我们都知道JavaScript中的作用域分全局作用域和函数作用域，函数是可以嵌套的，函数作用域也会嵌套在全局作用域下，这就会发生作用域的嵌套。当要查找的某个变量在当前作用域中不存在时，就会向上一级作用域中进行查找，直到全局作用域，这就形成了作用域链。
 其中
 > 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性的（向上搜索）、有次序（逐层）的。